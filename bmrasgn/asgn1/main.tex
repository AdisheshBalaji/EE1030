\documentclass{beamer}
\mode<presentation>
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{advdate}
\usepackage{adjustbox}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{url}
% \usepackage{minted}
% \usepackage{gvv}

\usepackage{tcolorbox}
\tcbuselibrary{minted,breakable,xparse,skins}



\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
  breakable=true,
  listing engine=minted,
  listing only,
  minted language=#2,
  minted style=default,
  minted options={%
    linenos,
    gobble=0,
    breaklines=true,
    breakafter=,,
    fontsize=\scriptsize,
    numbersep=8pt,
    #1},
  boxsep=0pt,
  left skip=0pt,
  right skip=0pt,
  left=25pt,
  right=0pt,
  top=3pt,
  bottom=3pt,
  arc=5pt,
  leftrule=0pt,
  rightrule=0pt,
  bottomrule=2pt,
  toprule=2pt,
  colback=bg,
  colframe=orange!70,
  enhanced,
  overlay={%
    \begin{tcbclipinterior}
    \fill[orange!20!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
    \end{tcbclipinterior}},
  #3,
}


\def\UrlBreaks{\do\/\do-}
\usetheme{Madrid}
\usecolortheme{lily}
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=\paperwidth,ht=2.25ex,dp=1ex,right]{author in head/foot}%
    \insertframenumber{} / \inserttotalframenumber\hspace*{2ex} 
  \end{beamercolorbox}}%
  \vskip0pt%
}
\setbeamertemplate{navigation symbols}{}

\providecommand{\nCr}[2]{\,^{#1}C_{#2}} % nCr 
\providecommand{\nPr}[2]{\,^{#1}P_{#2}} % nPr
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
\providecommand{\abs}[1]{\left\vert#1\right\vert}
\providecommand{\res}[1]{\Res\displaylimits_{#1}} 
\providecommand{\norm}[1]{\lVert#1\rVert}
\providecommand{\mtx}[1]{\mathbf{#1}}
\providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
%\providecommand{\hilbert}{\overset{\mathcal{H}}{ \rightleftharpoons}}
\providecommand{\system}{\overset{\mathcal{H}}{ \longleftrightarrow}}
	%\newcommand{\solution}[2]{\textbf{Solution:}{#1}}
%\newcommand{\solution}{\noindent \textbf{Solution: }}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\let\vec\mathbf

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}

\numberwithin{equation}{section}
\title{Matgeo: 4-4.2-21}
\author{J. Adishesh Balaji \\ AI24BTECH11016}

\date{\today}

\begin{document}
\begin{frame}
\titlepage
\end{frame}

\section*{Outline}
\begin{frame}
\tableofcontents
\end{frame}
\section{Problem}
\section{Solution}
\begin{frame}
\frametitle{Problem Statement}
%
Find the direction and normal vectors of the line.
\begin{align}
\label{eq:Line equation}
F &= \frac{9}{5} C + 32
\end{align}
\end{frame}


\subsection{Direction Vector}
\begin{frame}
\frametitle{Direction Vector}
The equation of line is given by \\
\begin{align*}
\myvec{C \\ F} &= \myvec{C \\ \frac{9}{5}C+32} \\
\myvec{C \\ F}	&= \myvec{0 \\ 32} + C\myvec{1 \\ \frac{9}{5}}
\end{align*}
which can be compared with \\
        \begin{align}
            \vec{x} &= \vec{h} + k\vec{m}
        \end{align}
Where $\vec{h}$ is any point on the line and \\
        \begin{align}
        \label{eq:directionvec}
            \vec{m} = \myvec{1 \\ \frac{9}{5}}
        \end{align}
is the direction vector
\end{frame}

\subsection{Normal Vector}
\begin{frame}
\frametitle{Normal Vector}
The normal vector can be found as follows \\
        \begin{align}
            \vec{m}^T\vec{n} &= 0 \\
            \vec{n}^T\vec{x} &= \vec{n}^T\vec{h} + k\vec{n}^T\vec{m} \\
            \vec{n} &= \myvec{-m \\ 1}
        \end{align}
Hence, the normal vector \\ 
        \begin{align}
        \label{eq:normalvec}
            \vec{n} = \myvec{-\frac{9}{5} \\ 1}
        \end{align}
The code in /bmrasgn/asgn1/codes/line.py verifies $\eqref{eq:directionvec}$ and $\eqref{eq:normalvec}$
\end{frame}


\begin{frame}[fragile,allowframebreaks]
\frametitle{C-code to generate Data}
\begin{mintedbox}{c}[break at=.8\textheight]
#include <stdio.h>
#include <stdlib.h>

// Function to generate points on the line F = (9/5)C + 32
void point_gen(FILE *fptr, double c1, double f1, double c2, double f2, int num_points) {
    for (int i = 0; i <= num_points; i++) {
        double t = (double)i / num_points;
        double c = c1 + t * (c2 - c1); // Linear interpolation for C
        double f = f1 + t * (f2 - f1); // Linear interpolation for F
        fprintf(fptr, "%lf,%lf\n", c, f);
    }
}

int main() {
    // Define two points on the line F = (9/5)C + 32
    double c1 = -50.0, f1 = (9.0 / 5.0) * c1 + 32.0;  // First point (C=-50, F)
    double c2 = 100.0, f2 = (9.0 / 5.0) * c2 + 32.0;  // Second point (C=100, F)
    
    // Open the file to save the points
    FILE *fptr = fopen("line_points.txt", "w");
    if (fptr == NULL) {
        printf("Error opening file!\n");
        return 1;
    }

    // Generate points on the line
    point_gen(fptr, c1, f1, c2, f2, 63);  // Generate 63 points on the line

    // Normal vector generation
    // The slope of the line is 9/5, so the slope of the normal is -5/9.
    double c_normal = c1, f_normal = f1;  // Take the first point for normal vector
    double norm_slope = -5.0 / 9.0;       // Slope of the normal line
    double norm_length = 50.0;            // Arbitrary length for the normal line

    double c_norm_end = c_normal + norm_length;
    double f_norm_end = f_normal + norm_slope * (c_norm_end - c_normal);

    // Generate points on the normal line
    point_gen(fptr, c_normal, f_normal, c_norm_end, f_norm_end, 20);

    // Close the file
    fclose(fptr);

    printf("Points on the line and normal vector saved to line_points.txt\n");

    return 0;
}


\end{mintedbox}
\end{frame}


\begin{frame}[fragile,allowframebreaks]
\frametitle{Python code to plot graph}
\begin{mintedbox}{Python}[break at=.8\textheight]
	import sys  # for path to external scripts
sys.path.insert(0, '/home/adishesh-balaji/github/matgeo/codes/CoordGeo')  # path to my scripts
import numpy as np
import numpy.linalg as LA
import matplotlib.pyplot as plt

# local imports
from line.funcs import *
from triangle.funcs import *
from conics.funcs import circ_gen

# Function to read points from the txt file
def read_points_from_file(filename):
    c_values = []
    f_values = []
    
    with open(filename, 'r') as file:
        for line in file:
            # Split the line by comma and convert to float
            c, f = map(float, line.strip().split(','))
            c_values.append(c)
            f_values.append(f)

    return np.array(c_values), np.array(f_values)

# Function to plot the line and its normal vector
def plot_line_and_normal(c_values, f_values):
    # Plot the line as a dotted line
    plt.plot(c_values, f_values, label=r'$F = \frac{9}{5}C + 32$', color='blue', linestyle='dotted')

    # Calculate the midpoint of the line
    midpoint_index = len(c_values) // 2
    c_mid = c_values[midpoint_index]
    f_mid = f_values[midpoint_index]

    # Midpoint as the starting point for the normal vector
    A_mid = np.array([c_mid, f_mid])

    # Direction vector (slope = 9/5)
    m = np.array([1, 9/5])

    # Normal vector (slope = -5/9)
    n = np.array([-9/5, 1])

    # Plot the main line using parametric form (starting at A = [0, 32])
    main_line_points = line_dir_pt(m, np.array([0, 32]), -50, 50)
    plt.plot(main_line_points[0, :], main_line_points[1, :], color='blue', linestyle='dotted')

    # Plot the normal vector emerging from the midpoint
    normal_points = line_dir_pt(n, A_mid, -20, 20)  # Adjust the range of the normal vector as needed
    plt.plot(normal_points[0, :], normal_points[1, :], label='Normal Vector', color='red', linestyle = 'dotted')

    # Set labels
    plt.xlabel('C (Celsius)')
    plt.ylabel('F (Fahrenheit)')
    plt.legend()

    # Set limits
    plt.xlim(-60, 110)
    plt.ylim(-70, 220)

    # Add grid
    plt.grid(True)
    plt.axhline(0, color='black', linewidth=0.5)
    plt.axvline(0, color='black', linewidth=0.5)

    # Show the plot
    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

# Main code execution
if __name__ == "__main__":
    filename = "line_points.txt"
    c_values, f_values = read_points_from_file(filename)
    plot_line_and_normal(c_values, f_values)

\end{mintedbox}
\end{frame}



\end{document}
